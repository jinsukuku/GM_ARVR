## Ch05.함수와 참조, 복사 생성자

### 함수의 인자 전달 방식
- 값에 의한 호출(call by value)
    - 값을 복사하여 전달하므로, 함수 내에서 실제 인자의 값을 손상시킬 수 없다
    - 즉, 함수 호출에 따른 부작용이 없다
    - [문제점] 매개 변수 객체의 생성자와 소멸자가 모두 실행되지 않는다 
        - 매개 변수 객체의 생성자는 실행되지 않고, 소멸자만 실행된다
        - 복사 당시의 상태를 잃을 수 있으므로, 생성자를 실행하지 않는다
        - 이처럼 매개 변수 객체의 생성자가 실행되지 않고 소멸자만 실행되는 구조를 `비대칭구조` 라고 말한다
        - `비대칭구조`: 생성자 없이 소멸자만 호출되는 비정상적인 흐름처럼 보이는 구조
    - [사실은] `복사 생성자` 가 호출된다
        - 값에 의한 호출 시, 매개 변수 객체의 생성자 대신 복사 생성자가 호출된다
        - 만약 클래스에 복사생성자가 작성되어있지 않다면 컴파일러는 디폴드 복사 생성자를 자동 생성한다
- 주소에 의한 호출(call by address)
    - 의도적으로 주소를 넘겨줘, 실제 인자의 값을 변경하고자 할 때 사용된다
    - 원본 객체를 복사X, 매개변수가 단순 포인터로, 생성자 소멸자의 비대칭 문제도 없다
    - 하지만 원본 객체를 훼손할 가능성이 있으므로 주의하자

<br>

### [정리] 값에 의한 호출 진짜 비대칭 구조인가?
- ❓값에 의한 호출(Call by Value)에서는 왜 비대칭 구조라고 하나요?
    - 값에 의한 호출은 함수로 객체를 복사해서 전달하는 방식
    - 이때, 복사 생성자 호출O, 일반 생성자 호출X
    - 그리고 함수 종료 시에는 소멸자는 반드시 호출됩니다.
    - 이 흐름이 **"생성자는 호출되지 않고 소멸자만 호출되는 것처럼 보인다"**는 점에서 비대칭 구조라고 부른다.
- ❓그런데 정말 비대칭인가? ❗ 진짜 비대칭은 아님
    - 실제로는 객체가 복사되면서 복사 생성자가 호출되므로, 객체는 정상적으로 생성 → 소멸의 절차를 거친다
    - 단지 **생성자와 소멸자의 쌍이 일반적인 형태(생성자-소멸자)**가 아니라 복사 생성자-소멸자라는 점이 비정상처럼 보일 수 있다는 의미
- 결론: 표현상 비대칭일 뿐, 실제 메커니즘은 정상적이다

<br>

### 객체 치환과 객체 리턴
```cpp
Circle c1(5);
Circle c2(30);

c1 = c2; // 객체 치환
```
- 객체 치환 시 객체의 모든 데이터가 비트 단위로 복사된다
- 객체 치환은 동일한 클래스 타입에 대해서만 적용된다
```cpp
Circle getCircle(){
    return Circle tmp(30);
}

Circle c;
c = getCircle();
```
- 객체를 리턴받는 경우도 객체 치환과 동일한 원리가 적용된다

<br>

### 참조자 `&`
- 포인터 변수를 선언할 때는 `*`, 참조 변수를 선언할 때는 `&` 를 사용한다
- `&` 를 우리는 **참조자** 라고 부른다
- 참조는 가리킨다는 의미로, 이미 선언된 변수에 대한 별명(alias)이다

<br>

### 참조의 활용(1) 참조 변수
```cpp
int n = 2;
int &refn = n;

Circle circle;
Circle &refc = circle;
```
- 이미 선언된 변수(원본 변수)에 대한 별명으로, 참조자(`&`)를 이용해 선언한다
- 선언 시 반드시 원본 변수로 초기화한다. 초기화하지 않는다면 컴파일 오류가 발생한다
- 선언된 참조 변수는 별도의 공간이 할당되지 않고, 원본 변수의 공간을 공유한다(포인터 개념X)
```cpp
char &n[10]; // 컴파일 오류. 참조변수는 배열을 만들 수 없다
```
- 참조 변수는 배열을 만들 수 없으니 주의하자


<br>

### 참조의 활용(2) 참조에 의한 호출(call by reference)
```cpp
void swap(int &a, int &b); // 참조 매개 변수를 사용한 함수

int m = 2, n = 9;
swap(m, n); // 참조에 의한 호출
```
- 참조 타입으로 선언된 함수의 매개 변수를 참조 매개변수라고 부른다
- 호출할 때 값에 의한 호출과 동일한 형태지만, 함수 원형에 의해 이는 참조에 의한 호출로 작동한다
- 참조 매개변수를 사용했으므로, 호출된 함수에는 stack에 참조 매개변수를 위한 공간이 할당되지 않는다. 단지 별명이므로!
- 참조 매개 변수는 단지 이름만 생성되므로, 생성자와 소멸자는 아예 실행되지 않는다
- [장점] 주소에 의한 호출은 주소를 전달하기 위해 `&` 연산자와 `*` 기호를 반복적으로 사용하므로, 실수의 가능성이 높고, 가독성이 떨어진다. 하지만 참조 매개 변수는 선언시에만 `&` 연산자를 사용하고 보통 변수처럼 사용하므로 보기 좋은 코드가 된다

<br>

### 참조의 활용(3) 참조 리턴
```cpp
char c = 'a';

char& find() return c;  // 반환 타입이 참조 변수 = 참조 리턴
// char find() return c; // 이건 그냥 값 복사됨. 명시해놓은 반환 타입에 따라 달라짐
char a = find();        // a = 'a' 가 됨 -> 참조하는 c 의 값을 대입해서

char &ref = find();     // ref는 c에 대한 참조 변수
ref = 'M';              // char c = 'M'

find() = 'b';           // char c = 'b'가 됨
```
- 값만 리턴 가능한 C언어와 달리, c++에서는 함수가 참조를 리턴할 수 있다
- `참조 리턴`이란 변수 등과 같이 현존하는 공간에 대한 참조의 리턴이다

<br>

### 복사 생성자(1) 얕은 복사와 깊은 복사
- 얕은 복사 (Shallow Copy)
    - 참조(주소)만 복사해서 동일한 메모리 공간을 가리킴
    - 두 객체가 같은 데이터를 공유하게 되어, 한 쪽이 데이터를 바꾸면 다른 쪽도 영향을 받음
    - 소멸자에서 delete를 둘 다 호출하게 되면 **이중 해제(double delete) 오류**가 날 수 있어 충돌 위험이 있다(이미 한번 호출한 시점에서 둘 다 해제되므로)
- 깊은 복사 (Deep Copy)
    - 동일한 타입의 포인터를 새로 만들고, 가리키는 실제 데이터를 복사
    - 서로 완전히 독립된 메모리 공간을 사용
    - 하나를 수정해도 다른 객체에 영향을 주지 않음, delete도 충돌하지 않음
    - 안전하지만 메모리 할당/복사가 추가로 필요하기 때문에 약간의 성능 비용이 든다
- 요약
    - 얕은 복사는 주소만 복사하여 같은 공간을 공유하므로 충돌 위험
    - 깊은 복사는 데이터를 새로 복사하므로 충돌 없이 독립적으로 사용 가능

<br>

### 복사 생성자(2) 복사 생성 및 복사 생성자
```cpp
class Circle{
private:
    int radius;
public:
    // 일반 생성자
    Circle(); 

    // 복사 생성자
    Circle(const Circle& c);        // 복사 생성자 선언
};

Circle:: Circle(const Circle& c){   // 복사 생성자 구현
    this -> radius = c.radius;
}
```
```cpp
Circle src(30); // 일반 생성자 호출
Circle dest(src); // src 객체를 복사, dest 객체 생성 = 복사 생성자 호출
```
- 복사 생성자의 매개 변수는 오직 하나이며, 자기 클래스에 대한 참조로 선언된다
- 복사 생성자는 클래스에 오직 하나만 선언할 수 있다

<br>

### 복사 생성자(3) 디폴트 복사 생성자
- 만약 복사 생성자를 직접 만들지 않으면 컴파일러는 `디폴트 복사 생성자` 를 묵시적으로 삽입한다
- `디폴트 복사 생성자` 는 얕은 복사를 실행한다. 만약 멤버 변수 중 포인터가 있다면 이중 해제의 위험이 발생한다.
- 위와 같은 이유로 깊은 복사가 필요한 경우 반드시 직접 복사 생성자를 선언해야 한다

<br>

### 복사 생성자(4) 사용자 깊은 복사 생성자 작성
```cpp
class Person{
    char* name;
    int id;
public: 
    Person(int id, const char* name);   // 일반 생성자
    Person(const Person& person);       // 복사 생성자
    ~Person(); // 소멸자
    ...
};


// 복사 생성자 구현
Person::Person(const Person& person){
    this->id = person.id;   // id값 복사

    // name 값 복사
    int len = strlen(person.name);      // name을 복사하기 위해 길이 확인(동적 할당 받으려고)
    this->name = new char [len+1];      // name을 위한 동적 할당
    strcpy(this->name, person.name);    // 문자열 복사 
}
```

<br>

### 복사 생성자(5) 묵시적 복사 생성
```cpp
// 1. 객체로 초기화하여 객체가 생성될 때
Person a(1, "Kim");   // 일반 생성자 호출
Person b = a;         // 복사 생성자 호출 (묵시적)
// Person b(a); 로 자동 변환되어 복사 생성자가 호출된다

// 2. 값에 의한 호출로 객체가 전달될 때
void printPerson(Person p) { // 복사 생성자 호출 (묵시적)
    // ...
}
Person a(2, "Lee");
printPerson(a);

// 3. 함수가 객체를 리턴할 때
Person createPerson() {
    Person temp(3, "Park");
    return temp; // 복사 생성자 호출 (묵시적, RVO 최적화 가능)
}

Person b = createPerson();

```
- 개발자도 모르게 복사 생성자가 묵시적으로 호출되는 경우가 있다. 
- 묵시적 디폴트 복사 생성자가 호출되어 프로그램이 비정상 종료될 수 있으니 주의하자.

<br>

### RVO(Return Value Optimaization)
- C++ 컴파일러가 불필요한 복사를 생략하여 성능을 최적화하는 기술
- 객체를 함수에서 리턴하는 경우, 일반적으로 `임시 객체 → 복사 생성자 → 대상 객체` 의 과정을 거친다
- 이 과정은 성능상 비효율 적이므로, 컴파일러가 중간 단계를 생략하고 임시 객체를 직접 대상 객체에 생성해주는 최적화 기법이 바로 `RVO` 기법
```cpp
class Person {
public:
    Person() { std::cout << "생성자\n"; }
    Person(const Person&) { std::cout << "복사 생성자\n"; }
    ~Person() { std::cout << "소멸자\n"; }
};

Person createPerson() {
    Person temp;
    return temp; // 여기서 복사 생성자가 호출될 수 있지만…
}

int main() {
    Person p = createPerson(); // RVO가 적용되면 복사 생성자 생략됨
}
```
- RVO가 적용된 경우의 출력: 생성자-소멸자
- RVO가 미적용된 경우의 출력: 생성자-복사생성자-소멸자-소멸자
- RVO는 컴파일러의 판단에 따라 자동으로 복사 생성자를 생략하고 불필요한 복사를 생략해 성능을 향상시킨다
- C++17 이후부터는 조건이 맞는 한 RVO가 필수적으로 적용(Mandatory RVO) 된다