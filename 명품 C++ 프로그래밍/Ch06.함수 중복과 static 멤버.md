## Ch06. 함수 중복과 static 멤버

### 함수 중복(function overloaing)
- C++에서는 같은이름의 함수를여러개 만들 수 있으며 이를 함수 중복이라고 부른다
- 함수 중복은 다형성의 한 사례로 전역 함수와 멤버 함수에 모두 적용되며, 상속 관계에 있는 기본 클래스와 파생 클래스 사이에서도 허용된다
- 함수 중복을 사용하면 작성이 편리하고 함수를 잘못 호출하는 실수를 줄일 수 있다

<br>

### 함수 중복 조건
```cpp
int sum(int a, int b, int c) return a + b + c;
double sum(double a, double b, double c) return a + b + c;
int sum(int a, int b)  return a + b;
double sum(double a, double b)  return a + b;
```
1. 중복된 함수들의 이름이 동일해야 한다
2. 중복된 함수들은 매개 변수 타입이나 매개 변수의 개수가 달라야 한다
```cpp
int sum(int a, int b)  return a + b;
double sum(int a, int b)  return a + b; // ERROR!
```
3. 함수 중복에 리턴 타입은 고려되지 않는다
    - 동일한 함수명, 매개 변수 타입과 개수가 모두 같고 리턴 타입만 다른 경우 함수 중복은 성립되지 않는다


<br>

### 함수 중복과 실행 시간
- C++ 컴파일러는 함수 중복이 성공적인지 판별하고 중복된 함수의 호출이 옳은 지 확인한다
- 함수 중복은 컴파일 시에 이루어지기 때문에, 이로인한 실행시간 저하는 없다

<br>

### 생성자 함수의 중복
```cpp
class Circle{
    int radius;
public:
    Circle();
    Circle(int r); 
    ...
}
```
- 객체를 생성할 때 매개 변수를 통해 다양한 형태로 초깃값을 전달하기 위해 생성자 함수를 중복 선언하기도 한다

<br>

### 소멸자 함수의 중복
- 소멸자는 매개 변수를 가지지 않기 때문에 **한 클래스에 오직 하나만 존재한다**
- 소멸자 함수의 중복은 **근본적으로 불가능하다**

<br>

### 디폴트 매개 변수
```cpp
void star(int a = 5);

star();     // a가 5로 자동 초기화
star(10);   // a = 10으로 초기화
```
- 함수가 호출될 때 매개 변수에 값이 넘어오지 않는 경우, 미리 정해진 디폴트 값을 받도록 선언된 매개 변수를 디폴트 매개 변수라고 말한다
- 디폴트 매개변수에 디폴트 값을 전달하는 것은 컴파일러에 의해 알아서 처리된다
- 디폴트 매개변수가 아닌 매개변수는 반드시 값을 전달해야한다
```cpp
void cal(int a, int b = 5, int c, int d = 0);      // ERROR
void sum(int a = 0, int b = 5, int c);             // ERROR
void avg(int a, int b = 5, int c = 2);             // GOOD
```
- 디폴트 매개 변수는 반드시 마지막 매개변수로 작성되어야한다

<br>

### 함수 중복 간소화
```cpp
class Circle{
    ...
public:
    Circle() {radius = 1;}
    Circle(int r) {radius = r;}
    Circle(int r = 1) {radius = r;} // ERROR! 디폴트 매개변수를 사용하면 중복 함수 불가능 
}
```
- 디폴트 매개 변수의 최대 장점은 함수 중복을 간소화 할 수 있다는 점이다
- [주의] 디폴트 매개 변수를 가진 함수는 같은 이름의 중복 함수들과 함게 사용될 수 없다

<br>

### 함수 중복의 모호성
```text
(1) 형 변환으로 인한 모호성
(2) 참조 매개 변수로 인한 모호성
(3) 디폴트 매개 변수로 인한 모호성 
```
- 함수 중복의 조건을 갖추었더라도 호출이 모호한 경우가 발생할 수 있다
- 함수 호출이 모호한 경우 컴파일러는 오류를 발생시키므로 주의해서 함수를 중복 작성해야한다

<br>

### 함수 중복의 모호성(1) 형 변환으로 인한 모호성
```cpp
double square(double a); // double 타입 매개변수 가진 함수
...
square(3);  // int 타입 매개변수 전달 -> 오류 발생X
```
- 작은 타입(int)를 큰 타입(double)로 자동 형 변환해서 사용하므로 컴파일 오류가 발생하지 않는다
```cpp
float square(float a);
double square(double a);
...
suare(3);
```
- 앞선 케이스와 동일하게 작은 타입을 자동 형 변환해서 사용할거라고 생각하지만 컴파일 오류가 발생한다
- float타입과 double타입에 명확하게 해당하지 않고 자동 형변환이 둘 다 가능하므로 호출해야하는 함수가 모호하기때문에 컴파일 오류가 발생한다
- 컴파일러가 임의로 선택하면 개발자의 의도와 다른 결과가 나올 수 있으므로, 모호한 호출로 판정해 컴파일 오류를 발생시킨다

<br>

### 함수 중복의 모호성(2) 참조 매개 변수로 인한 모호성
```cpp
int add(int a, int b);
int add(int a, int &b);

int s = 10, t = 20;
add(s, t); //컴파일 오류 -> 호출 모호
```
- 중복된 함수 중 참조 매개 변수를 가진 함수가 있는 경우 이들 사이의 모호성이 존재할 수 있다 
- 중복 함수 중 어떤 함수를 호출해야하는지 모호하므로 컴파일 오류를 발생시킨다
    - 선언된 매개 변수 타입이 참조 변수더라도, 호출 시에는 변수명만 넘기므로

<br>

### 함수 중복의 모호성(3) 디폴트 매개 변수로 인한 모호성
```cpp
void msg(int id);
void msg(int id, string s="");

msg(6); // 컴파일 오류 -> 호출 모호
```
- 디폴트 매개 변수를 사용하는 경우 작성하지 않아도 되기때문에 어떤 함수를 호출해야하는지 모호하므로 컴파일 에러가 발생한다

<br>

### static 멤버
```cpp
class Person{
public:
    int money;
    void addMoney(int money){
        this -> money += money;
    }
    static int shareMoney;
    static void addShareed(int n){
        shareMoney += n;
    }
};

int Person::shareMoney = 10;    // static 멤버변수는 반드시 전역 공간에서 초기화한다
```
- `static`은 변수와 함수의 생명주기와 사용 범위를 지정하는 방식 중 하나
- `static`으로 선언된 변수와 함수의 생명 주기와 사용 범위는 아래와 같은 특징을 갖는다
    - 생명 주기: 프로그램이 시작할 때 생성되고 프로그램이 종료할 때 소멸한다
    - 사용 범위: 변수나 함수가 선언된 범위 내에서 사용. 전역 혹은 지역으로 구분한다
- `static`으로 선언된 멤버는 클래스에 종속되며 모든 인스턴스가 하나의 멤버를 공유한다
    - `static` 멤버 변수는 선언만 클래스 안에서 이루어지고, 실제 메모리 공간은 할당X
    - 따라서 이 변수의 메모리 공간을 할당하고 초기값을 설정하려면, 클래스 외부의 전역 공간에서 별도로 초기화하는 코드가 반드시 필요
    - 전역 공간에서 초기화하는 이유는 **static 멤버 변수가 클래스 인스턴스마다 생성되는 것이 아니라 프로그램 시작 시 단 한 번 생성되어야 하기 때문**
- `non-static` 멤버는 인스턴스마다 별도로 생성되고 관리

<br>

### static 변수 vs non-static 변수
| 항목           | non-static 멤버                        | static 멤버                               |
|----------------|--------------------------------------|------------------------------------------|
| 선언 사례  | class Sample { int n; void f(); };  | class Sample { static int n; static void f(); }; |
| 공간 특성      | 멤버는 객체마다 별도 생성           | 멤버는 클래스당 하나 생성               |
|                | (인스턴스 멤버)                     | (클래스 멤버라고 부름)                   |
|                | 객체 내부에 공간 생성               | 객체 내부가 아닌 별도의 공간에 생성     |
| 시간적 특성    | 객체와 생명을 같이 함               | 프로그램과 생명을 같이 함                |
|                | - 객체 생성 시 멤버 생성            | - 프로그램 시작 시 멤버 생성             |
|                | - 객체 소멸 시 멤버 소멸            | - 객체가 생기기 전부터 존재              |
|                | - 객체 생성 후 사용 가능             | - 객체가 사라져도 계속 존재               |
|                |                                    | - 프로그램 종료 시 소멸                   |
| 공유의 특성    | 공유되지 않음                       | 동일 클래스의 모든 객체가 공유            |
|                | 객체별로 각각 공간 유지             |                                          |

<br>

### static 멤버 사용
```cpp
// static멤버를 가지는 클래스 정의
class Person{
public:
    int money;
    void addMoney(int money){
        this -> money += money;
    }
    static int shareMoney;
    static void addShareed(int n){
        shareMoney += n;
    }
};

int Person::shareMoney = 10;    // static 멤버변수는 반드시 전역 공간에서 초기화한다
```
```cpp
//(1) 객체의 멤버로 접근하는 방법
Person lee;
lee.shareMoney = 500; // 객체 이름으로 접근

Person *p;
p = &lee;
p -> addShared(200); // 객체 포인터로 접근
```
```cpp
//(2) 클래스명과 범위 지정 연산자(::)로 접근
Person::shareMoney = 200;   // 클래스명과 범위 지정 연산자로 접근
Person::addShared(200);
```

<br>

### static의 활용: 전역 변수나 전역 함수를 클래스에 캡슐화
- 캡슐화: 캡슐화는 객체의 데이터(멤버 변수)를 외부에서 직접 접근하지 못하도록 숨기고, 대신 getter/setter 같은 함수로 안전하게 접근하도록 하는 객체지향의 핵심 원칙이다. 이를 통해 데이터 무결성을 보호하고 내부 구현을 숨길 수 있다.
- 같은 객체 지향 언어이지만, Java와 다르게 C++은 C언어와의 호환성때문에 100% 캡슐화 할 수 없다
- 그렇기 때문에 static멤버를 사용해 모두 캡슐화 하는 것이 최선이다

<br>

### static 멤버 함수의 특징
- static 멤버 함수는 오직 static 멤버 변수에 접근하거나 static 함수만 호출할 수 있다
- 프로그램이 시작되기만하면 사용 가능하므로 non-static 멤버에 접근하는 것은 허용되지 않는다
- static 멤버 함수는 this를 사용할 수 없다
    - 객체가 생기기 전부터 호출 가능하므로, 객체 자신을 가리키는 `this`는 사용할 수 없다
